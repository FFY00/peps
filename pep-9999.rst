PEP: 9999
Title: Graceful cooperation between external and Python package managers
Author: Geoffrey Thomas <geofft@ldpreload.com>, Matthias Klose <doko@ubuntu.com>, FFY00, Donald Stufft <donald@python.org>, TP Chung, Stefano Rivera <stefanor@debian.org>, Elana Hashman <ehashman@debian.org>, Pradyun Gedam <mail@pradyunsg.me>
Discussions-To: TODO discourse
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created: 2021-05-18
Post-History:

Abstract
========

This PEP proposes a mechanism to indicate that a certain Python
interpreter's package installation is managed by external means (such as
an OS package manager) and that Python-specific package management tools
like pip should, by default, neither install nor remove packages in an
interpreter-wide context, guiding the end user towards using a virtual
environment.

It also standardizes an interpretation of the ``sysconfig`` schemes so
that, if a Python-specific package manager is specifically instructed to
install a package in an interpreter-wide context, it can do so in a
manner that avoids conflicting with the external package manager and
reduces the risk of breaking software shipped by the external package
manager.

Motivation
==========

Thanks to Python's immense popularity, software distributions (by which
we mean Linux and other OS distributions as well as overlay
distributions like Homebrew and MacPorts) generally ship Python for two
purposes: as a software package to be used in its own right by end
users, and as an implementation language for other software in the
distribution.

For example, many distributions ship a ``/usr/bin/python3`` command which is
both the ``python3`` command available to end users as well as the
``#!/usr/bin/python3`` shebang for Python-language software. Because
there are no official binary releases of Python for Linux/UNIX, almost
all Python end users on these OSes use the Python interpreter built and
shipped with their distribution.

These are typically the same command, which means that if an end user
installs a Python package using a tool like ``pip`` outside the context
of a virtual environment, the new package is visible to Python-language
software shipped by the distribution. If the new package is not
backwards-compatible, it may break software shipped by the distribution.

This problem is particularly extreme because many distributions have
package-management tools that are themselves written in Python. It's
possible to unintentionally break Fedora's ``dnf`` command or Ubuntu's
Software Center with a ``pip install`` command, making it hard to
recover.

This applies both to system-wide installs (``sudo pip install``) as well
as user home directory installs (``pip install --user``), since
packages in either location show up on the ``sys.path`` of
``/usr/bin/python3``.

There is a worse problem with system-wide installs: if you attempt to
recover from this situation with ``sudo pip uninstall``, you may end up
removing packages that are shipped by the system's package manager. In
fact, this can even happen if you simply upgrade a package - pip will
try to remove the old version of the package, as shipped by the OS. At
this point it may not be possible to recover the system to a consistent
state using just the software remaining on the system.

Over the past many years, a consensus has emerged that the best way for
end users to install Python libraries or applications (when not using a
distribution package) is to use a virtual environment. This approach was
popularized by the PyPA `virtualenv`_ project, and a simple version of
that approach is now available in the Python standard library as
``venv``. Installing a Python package into a virtualenv prevents it from
being visible to the unqualified ``/usr/bin/python3`` interpreter and
prevents breaking system software.

.. _virtualenv: https://virtualenv.pypa.io/en/latest/

In some cases, however, it's useful and intentional to install a Python
library from outside of the distribution that influences the behavior of
distribution-shipped commands. This is common in the case of software
like Sphinx or Ansible which have a mechanism for writing
Python-language extensions. A user may want to use their distribution's
version of the base software (for reasons of paid support or security
updates) but install a small extension from PyPI, and they'd want that
extension to be importable by the software in their base system.

While this continues to carry the risk of installing a newer version of
a dependency than the operating system expects, it does not need to
carry the risk of removing files from the operating system. A tool like
pip should be able to install packages in some directory on the default
``sys.path``, if specifically requested, without deleting files owned by
the system's package manager.

Therefore, this PEP proposes two things.

First, it proposes a way for distributors of a Python interpreter to
mark that interpreter as having its packages managed by means external
to Python, such that Python-specific tools like pip should not change
the installed packages in the interpreter's global ``sys.path`` in any
way (add, upgrade/downgrade, or remove) unless specifically overridden.
It also provides a means for the distributor to indicate how to use a
virtual environment as an alternative.

This is an opt-in mechanism: by default, the Python interpreter compiled
from source will not be so marked, and so running ``pip install`` with a
self-compiled interpreter, or with a distribution that does not mark its
interpreter in this way, will work as it always has worked.

Second, it sets the rule that when installing packages to an
interpreter's global context (either to an unmarked interpreter, or if
overriding the marking), Python-specific package managers should
delete files only within the directories of the ``sysconfig`` scheme in
which they would create files. This permits a distributor of a Python
interpreter to set up two directories, one for its own managed packages, and
one for unmanaged packages installed by the end user, and ensure that
installing unmanaged packages will not delete (or overwrite) files owned
by the external package manager.

Rationale
=========

- We want Docker containers to keep working, even though it's not great

``PYTHONHOME`` overrides stdlib and site-packages
venv does not override stdlib is easy to detect
we should therefore always ignore it in a venv

``pyvenv.cfg`` mechanism - ``sys.base_prefix == sys.prefix``
this _might_ not be true of old versions of virtualenv. pip supports 3.6+, check what's supported

    # pip calls get_default_scheme()
    # -- Debian might return 'posix_prefix'
    pip install xxx
    
    # pip calls get_preferred_scheme('prefix')
    # -- Debian might return 'posix_prefix'
    pip install --prefix=/some/path xxx
    
    # pip calls get_preferred_scheme('user')
    # -- Debian might return 'posix_user'
    pip install --user xxx

--system-site-packages

have a matrix of behavior for these use cases, current + future

use case 1: Python configured without Felipe's patch - without option to support another site directory
- can you pip install? yes => yes
- can you delete things shipped by the OS? yes => yes
use case 2: Debian, attempt systemwide pip install
- yes => no
- yes => no
use case 3: Debian, attempt pip install in virtualenv
- yes => yes
- irrelevant
use case 4: Debian, attempt systemwide pip install in Docker container
- yes => yes
- no (because of the Debian patch, unless you sudo pip install -U pip) => no --- is this harmless???
  - in the future, => yes via ``pip install --scheme=posix_distro`` or
    whatever we call it
use case 5: geofft building a Python for users, wants them not to run pip.
- yes => no
- yes => no
use case 6: Fedora running pip inside an RPM build, checking for ``$RPMBUILD``
- yes => ... yes I think? presumably the build chroot would d have some way to suppress
    this file during package build if you're going to install packages via
    pip
- yes => no (assuming Fedora doesn't have the Debian patch)

Specification
=============

Marking an interpreter as using an external package manager
-----------------------------------------------------------

Before a Python package installer (that is, a tool such as pip - not an
external tool such as apt) installs a package into a certain Python
context, it should make the following checks by default:

1. Is it running outside of a virtual environment? It can determine this
by whether ``sys.prefix == sys.base_prefix``.

2. Is there a ``EXTERNALLY-MANAGED`` file in the directory identified by
``sysconfig.get_path("stdlib", sysconfig.get_default_scheme())``

If both of these conditions are true, the installer should exit with an
error message indicating that package installation into this Python
interpreter's directory are disabled outside of a virtual environment.

The installer should have a way for the user to override these rules,
such as a command-line flag ``--break-system-packages``.

If the ``EXTERNALLY-MANAGED`` file parses as an ``email.message`` , the
installer should output an error message from that file as part of its
error. If the header variable ``Error-XY`` where ``XY`` is the current
locale's language code exists, then it should use the value of that
header as the error; otherwise, it should use the body of the message as
the error. If the file does not parse as an ``email.message`, then the
installer should output an error message of its own.

Software distributors who have a non-Python-specific package manager
that manages libraries in the ``sys.path`` of their Python package
should, in general, ship a ``EXTERNALLY-MANAGED`` file in their standard
library directory. For instance, Debian may ship a file in
``/usr/lib/python3.*/EXTERNALLY-MANAGED`` consisting of something like

::

    To install Python packages systemwide, try apt install python3-xyz,
    where xyz is the package you are trying to install.

    If you wish to install a non-Debian-packaged Python package, create
    a virtual environment using python3 -m venv path/to/venv. Then use
    path/to/venv/bin/python and path/to/venv/bin/pip. Make sure you have
    python3-full installed.

    If you wish to install a non-Debian packaged Python application, it
    may be easiest to use pipx install xyz, which will manage a
    virtual environment for you.

    See https://wiki.debian.org/Python/venv for more information.

which provides useful and distribution-relevant information to a user
trying to install a package.

In certain contexts, such as single-application container images that
aren't updated after creation, a distributor may choose not to ship an
``EXTERNALLY-MANAGED`` file, so that users can install whatever they
like (as they can today) without having to manually override this rule.

Writing to only the target ``sysconfig`` scheme
-----------------------------------------------

Usually, a Python package installer installs to directories in a
scheme returned by the ``sysconfig`` standard library package.
Ordinarily, this is the scheme returned by
``sysconfig.get_default_scheme()``, but based on configuration (e.g.
``pip install --user``), it may use a different scheme.

Whenever the installer is installing to a ``sysconfig`` scheme, this PEP
specifies that the installer should never modify or delete files outside
of that scheme. For instance, if it's upgrading a package, and the
package is already installed in a directory outside that scheme (perhaps
in a directory from another scheme), it should leave the existing files
alone.

If the installer does end up shadowing an existing installation during
an upgrade, we recommend that it produces a warning at the end of
its run.

If the installer is installing to a location outside of a ``sysconfig``
scheme (e.g., ``pip install --target``), then this subsection does not
apply.

Recommendations for distributions
=================================

This section is non-normative. It provides advice we think is a good
idea for distributors of Python to follow unless they have a specific
reason otherwise.

- create this file
- delete this file in your Docker image, do so in a way that makes it
  not come back if someone does the equivalent of a ``RUN apt-get
  dist-upgrade``
- in the error message, recommend pipx for applications, for now - it
  will create a virtualenv for you, it does the right thing out of the
  box for applications
- set up two paths, one for distro, one for pip - configure the default
  one to be the one suitable for pip


Rejected alternatives
=====================

Put the file in sys.path - wrong place (--user)

Put the file in ``sysconfig`` itself - hard to configure

- Should not be in ``/etc`` because linuxbrew etc.

Should not be in ``pip.conf`` because it is not pip-specific.
File could be TOML
File could be a script

Don't allow shadowing - UX complexity

Allow distro software to run without the site-installed packages - this
is a good idea, but outside the scope of this PEP

We should get ``sys.is_virtual_env`` and ``sysconfig.is_externally_managed``
into the stdlib

Why not use ``INSTALLER`` (PEP-0627)?
- It's in the dist-info directory, so it doesn't tell us about
  environment/shadowing
- It's informational: "specified to be used for informational purposes
  only. [...] Our goal is supporting interoperating tools, and basing
  any action on which tool happened to install a package runs counter to
  that goal."
- Sometimes you do want to remove things installed by someone else (e.g.
  pip installs, conda removes), sometimes you don't (apt installs, pip
  removes)

Why not disable installs inside a virtualenv? YAGNI / pip uninstall pip

References
==========

We can open these before the PEP is accepted and should link to these:

PR to pip for EXTERNALLY-MANAGED + ``--break-system-packages``

PR to pip for hands-off-system-packages.patch v2

MR to Debian Python to create the EXTERNALLY-MANAGED file

PR to upstream Python for is_virtual_env/is_externally_managed maybe?

TODO
====

Contact Conda, Poetry, Flit (takluyver), Homebrew/Linuxbrew, pfmoore

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
